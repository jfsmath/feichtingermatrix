function gp = g_plus_ldl(A,n,rk)
% Approximate the symmmetric 1-nuclear norm of a psd matrix A
% n = ambient dimension
% rk = rank
% This algorithm  performs a random search for an upper bound for \gamma_+
% For each dimension, we generate num_trials number of random rotation.
% These rotataions perturb the column space of A (generated by symmmetric
% rank-two tensors), starting with the eigen-decomposition of A.

   
    num_trials = 16; % number of perturbations for each rank
    rep = 2^rk*num_trials; % total number of repetition
    
    gp_temp = zeros(1,rep+1); % keep tabs on upper bound of gamma_+
    

    % Using Eigendecomposition
    % [V,E] = eig(A);
    % E = sqrt(E);
    % V = (E*V')'; 


    % Using LDL (for Cholesky)
    [L,D,P] = ldl(A);
    
    % tol = 1e-8; % tolerance for floating point arithmetic
    % nonzero_indices = (abs(diag(D)) > tol); % Find the nonzero column index from E
    
    
    nonzero_indices = (round(diag(D)) ~= 0);
    E = sqrt(D);
    V = P*L*E;
    
    carat_num = rk*(rk+1)/2; % number of extremal points from Caratheodory's THM

    if n >= rk

        % if using the eigen decomposition
        % extracting the last rk columns from V
        % corresponding to nonzero eigenvalues

        % r = n-rk+1;
        % V = V(:, r:n); 

        % if using the LDL decomposition
        
        V = V(:,nonzero_indices); % Extract the nonzero columns from V
        % V = V(:,1:rk); % extracting the first rk columns from V


        % Randomly perturb the decomposition num_trials times
        for i = 1:rep
        J = randn(carat_num,carat_num);
        [O,~] = qr(J); % generate a random rotation matrix via QR decomposition
        O = O(1:rk,:);
        V_temp = V*O;  % rotate the eigendecomposition of A by O, still have A = V_tempV_temp*
        gp_temp(1,i) = one_two_norm(V_temp); % Keep track of gamma_plus for each rotation
        end
        % Include the original eigen decomposition
        gp_temp(1,rep+1) = one_two_norm(V);
    else
        for i = 1:rep
        J = randn(n,n);
        [O,~] = qr(J); % generate a random rotation matrix via QR decomposition
        V_temp = V*O;  % rotate the eigendecomposition of A by O, still have A = V_tempV_temp*
        gp_temp(1,i) = one_two_norm(V_temp); % Keep track of gamma_plus for each rotation
        end
        % Include the original eigen decomposition
        gp_temp(1,rep+1) = one_two_norm(V);
    end

    
    % Minimum of all these 
    gp = min(gp_temp);
    

end